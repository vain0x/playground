# Algebraic Parser

WIP

いまのところ適当にバックトラックするインタプリタしか実装していない

## 概要

代数的パーサ (AP) はパーサを作るライブラリのアーキタイプ

- 小さい構文規則の組み合わせで言語全体の構文規則を作る
- 規則のパース時に値を生み出す
    - 典型的にはパースされた規則に対応する構文木のノードを作る
    - 複数のサブ規則からなる複合規則は、サブ規則が生成した値を組み合わせて値を作る

### 規則

Tはトークン、Sは非終端記号、Rは規則のメタ記号である

- `'T'`: **トークン**。特定の種類のトークンの出現
- `'T'!`: **カット**。特定の種類のトークンの出現。囲まれている選択をカットする
- `recurse(S)`: **再帰**。非終端記号Sを適用する
- `R1 R2`: **連接**。規則R1, R2を順に適用する
- `choice(R1 | R2)`: **選択**。規則R1, R2のうち、それに含まれているカット規則に到達できるほうを適用する
- `infixLeft(R1, R2, R3)`: **左再帰**。規則R1を適用し、R2が適用可能であるかぎり `R2 R3` を繰り返し適用する

### 記法

- 再帰的な非終端記号を `S = recursive` で表す
- パーサは `(S, { S1: R1, ... })` で表す
    - Rはパーサの開始記号
    - `S_i`, `R_i` は非終端記号と対応する規則の組み合わせ

### 例: 算術式

```
Expr = recursive

Primary = choice( 'number'!
                | '('! recurse(Expr) ')' )

Mul = infixLeft(Primary, choice('*'! | '/'!), Primary)

Add = infixLeft(Mul, choice('+'! | '-'!), Mul)

Parser = (Expr, { Expr: Add })
```

- 非終端記号 `Expr` は数式の構文規則を表すことにする。この時点ではその規則を定義できないので、再帰的な非終端記号として宣言している
- 規則 `Primary` は式の一種で、乗算の両辺に出現できる結合力を持つものを表している
    - 数値と、カッコで囲まれた式が該当する
    - 選択はカットされている数値と左カッコのどちらかを先読みして規則を選ぶ
- 規則 `Mul` は式の一種で、乗算以上の結合力を持つものを表している
    - パーサは次のように動く。はじめに規則 `Primary` をパースする。次に `*` または `/` が先読みできるかぎり、そのトークンと `Primary` をパースする、ということを繰り返す
- 規則 `Add` は `Mul` と同様で、加算以上の結合力を持つ式を表す
- 最後の行は、算術式の構文規則が `Expr` であることと、非終端記号 `Expr` の定義は `Add` であることを述べている

### 比較

モナディックな **パーサコンビネータ** とは根本的に異なる

- パーサコンビネータはパーサを合成する
    - 一方、APは構文規則を組み立てる
- **性質の静的解析**。パーサコンビネータのパーサは実行時に任意の条件で分岐できるので、それがパースする構文の性質を静的に解析したりできない
    - 一方、APは構文規則を形式的に表現しているので、解析できる
- **表現力**。パーサコンビネータは作りようによってはどんな構文でもパースできる
    - 一方、APは構文規則の組み合わせで表現できる構文しかパースできない

**パーサジェネレータ** とは似ている。APは実行時に動作するパーサジェネレータといえる

- コントロールフローをジェネレータ側が決めるという点は同じ
- 静的コード生成を含まない
    - APは実行時に動作するので、ビルドチェインに組み込む必要がない
- 外部DSLがいらない
    - APのほうが、入力支援や型検査の恩恵を受けやすい
- パーサジェネレータによってはライブラリ由来の構文木しか得られないことがある
    - APは、利用者が定義した抽象構文木を生成できる

### 構想

実装できていない

- 繰り返し: `R?`, `R*`, `R+`
    - Rの中はブランチなのでカットが必要
- 性能:
    - 構文規則の選択を行う際に先読みされたトークンから選択される規則へのマッピングを事前に準備することで、パース処理の計算量を線形にしたい (入力トークン数Nに対してO(N)時間)
        - LL(k)に制限する
    - パーサを非再帰にしたい
- 検査:
    - choiceの対称性、構文に曖昧性がないことを検査したい
- エラー報告
    - 位置の報告、トークンのスキップによるリカバリー
- とっつきやすさ
    - ビルドツールのエラーやパース中の無限ループといったリカバリーしづらい問題を防げるライブラリになったら便利な気がする

### See Also

Inspired from: [Semantic Domain: A Typed, Algebraic Approach to Parsing](https://semantic-domain.blogspot.com/2018/07/a-typed-algebraic-approach-to-parsing.html)

上記記事は構文規則に型検査のような静的検査をかけること、多段階計算によりパーサを部分評価することも提案している。
このリポジトリはそこまでやってない
