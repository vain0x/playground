# 文法の問題

本の記述を参考にパーサジェネレータを作っている。
しかしパースできそうにない構文がみつかった

文法の簡略化した定義:

    # (開始記号) ブロック。0個以上の宣言と、1個以上の文の並びを波カッコで囲んだもの
    %start
    block : '{' decs stmts '}';

    # 関数宣言のような構文。例: `T f() { x = y; }`
    dec : ID ID '(' ')' block;

    decs : /* empty */
         | dec decs;

    # 代入文のような構文。例: `x = y;`
    stmt : ID '=' ID ';';

    stmts : stmts stmt
          | stmt;

問題となる入力 (A):

    {
        T f() { a = b; }
        c = d;
    }

別の入力 (B):

    {
        T f() { a = b; }
        c d() { x = y; }
        z = w;
    }

これらの入力をパースしようとして、2行目の関数fの宣言をdecで還元した状態まで進んだとする。
2行目の行末にある '}' はシフト済みで、次の記号は `ID` (代入の左辺の `c`) である。
(ここまではどちらも同じ)

この状態におけるLR項の集まりは:

    block → '{' decs ・ stmts '}'
    dec → ・ ID ID '(' ')' block
    decs → ・
    decs → ・ dec decs
    decs → dec ・ decs
    decs → dec decs ・
    stmt → ・ ID '=' ID ';'
    stmts → ・ stmts stmt
    stmts → ・ stmt

入力Aの場合、次にくるのはが代入文 (`c = d;`) なので、ここで `decs` を還元して `stmts` のパースに移ってほしい。
(その後、`;` までシフトしてから `stmt` で還元する。
`stmts` に還元して `}` をシフトすることで開始記号 `block` を還元する、という流れ)

入力Bの場合、次にくるのも関数宣言 (`c d() {...}`) なので、ここではシフトしてほしい。
(その後、関数宣言の '}' までシフトした後にdecを還元する。
次に空列からdecsに還元し、`dec decs` からdecsを還元する。
2行目の関数宣言であるdecと、いま作ったdecsで改めて `decs` を還元する。
その後 `z` をシフトして `stmts` のパースに入る。後は入力Aと同様の流れ)

前述の状態では、先読み `ID` のとき行う操作をシフトと還元のどちらにしてもうまくいかない。
したがって、この構文はLR(1)ではない…… ような気がする……
