# 最適化コンパイラ

最適化するコンパイラの実装を試す

## 抽象構文

C風の文指向な構文を持つ

```
    型 T =
        void
        | bool
        | int
        | string
        | ident
        | array(T)

    式 E =
        literal
        | ident                 変数
        | ident( E, ... )       関数呼び出し式
        | E[ E ]                インデックス式
        | E.field               フィールド式
        | ( E )                 カッコ式
        | [ E, ... ]            配列式
        | { f: E, ... }         レコード式
        | !E                    否定
        | E + E                 加算
        | E == E                等価性の比較

    文 S =
        E ;                         式文
        | let ident ( : T )? = E ;  束縛
        | E = E ;                   代入
        | break ;
        | continue ;
        | return E? ;
        | if E block
          else ( block | if )
        | loop block
        | while E block

    block =
        { S... }

    宣言 D =
        fn ident( param, ... ) -> T block   関数の宣言
        | type ident { f: T, ... }          レコード型の宣言

    param =
        ident : T
```

## 具象構文

カンマやセミコロンを省くために、追加のルールがある

### カンマの扱い

- 行末のカンマは省略できる

### セミコロンの扱い

- 行末のセミコロンは省略できる
- 右カッコの直前のセミコロンは省略できる

### スペースの有無

構文を明確にするため、記号に隣接するスペースの有無を利用する部分がある

- 一部の記号は左隣にスペースを挟むことができない
    - 関数呼び出しの左カッコ
    - インデックス式の左カッコ
    - 関数宣言におけるパラメータリストの左カッコ
- 一部の記号は右隣にスペースを挟むことができない
    - フィールド式のドット
    - 前置演算子
- 二項演算子は、左隣にスペースがあるなら右隣にもスペースが必要

例:

- `f (x)` の `(` は左隣にスペースがあるため関数呼び出しとして解釈されない
- `x. y` の `.` は右隣にスペースがあるためフィールド式のドットとして解釈されない
- `- x` の `-` は右隣にスペースがあるため前置演算子として解釈されない
- `(x -z)` の `-` は左隣のスペースがあって右隣にスペースがないため二項演算子として解釈されない

余談:

- 演算子の前後のスペースの有無 (個数ではない) を利用するのは F# を参考にしている
- 標準的なフォーマットは、上記のルールにおのずと従っているはず
- 改行やスペースの有無は視覚的に分かりやすいため、スペース依存の挙動が混乱を招くことは少ないと思う
