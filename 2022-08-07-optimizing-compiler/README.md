# 最適化コンパイラ

最適化するコンパイラの実装を試す

## 抽象構文

C風の文指向な構文を持つ

```
    型 T =
        void
        | bool
        | int
        | string
        | ident
        | array(T)

    式 E =
        literal
        | ident                 変数
        | ident( E, ... )       関数呼び出し式
        | E[ E ]                インデックス式
        | E.field               フィールド式
        | ( E )                 カッコ式
        | [ E, ... ]            配列式
        | { f: E, ... }         レコード式
        | !E                    否定
        | E + E                 加算
        | E == E                等価性の比較

    文 S =
        E ;                         式文
        | let ident ( : T )? = E ;  束縛
        | E = E ;                   代入
        | break ;
        | continue ;
        | return E? ;
        | if E block
          else ( block | if )
        | loop block
        | while E block

    block =
        { S... }

    宣言 D =
        block
        | fn ident( param, ... ) -> T block 関数の宣言
        | type ident { f: T, ... }          レコード型の宣言

    param =
        ident : T
```

## 具象構文

カンマやセミコロンを省くために、追加のルールがある

### カンマの扱い

- 行末のカンマは省略できる

### セミコロンの扱い

- 行末のセミコロンは省略できる
- 右カッコの直前のセミコロンは省略できる

### スペースの有無

構文を明確にするため、記号に隣接するスペースの有無を利用する部分がある

- 一部の記号は左隣にスペースを挟むことができない
    - 関数呼び出しの左カッコ
    - インデックス式の左カッコ
    - 関数宣言におけるパラメータリストの左カッコ
- 一部の記号は右隣にスペースを挟むことができない
    - フィールド式のドット
    - 前置演算子
- 二項演算子は、左隣にスペースがあるなら右隣にもスペースが必要

例:

- `f (x)` の `(` は左隣にスペースがあるため関数呼び出しとして解釈されない
- `x. y` の `.` は右隣にスペースがあるためフィールド式のドットとして解釈されない
- `- x` の `-` は右隣にスペースがあるため前置演算子として解釈されない
- `(x -z)` の `-` は左隣のスペースがあって右隣にスペースがないため二項演算子として解釈されない

### 余談: セミコロン自動挿入との比較

- セミコロンの記述はめんどうごと (認識負荷) の1つ
- セミコロンをなるべく書かなくてよい具象構文を設計したい
    - F# のレイアウト依存構文はセミコロン以上にめんどう
- Go風のセミコロン自動挿入が有望
    - 字句解析の時点で解決できる、ルールが単純で人間にも分かりやすい、実装しやすい、性能上の問題がない、などの利点がある
    - 1つだけ欠点がある: 式が複数行にわたるときフィールド式のドットや二項演算子を改行の前 (前行の行末) に書くことになり、他の言語の標準的なフォーマッティングに反する
    - 大きな瑕疵というほどではないが、解消できないか検討の余地はある
- スペース依存性
    - 記号の前後のスペースの有無を利用するのは F# を参考にしている
    - スペースの量ではなく有無だけみるのがポイント
        - 改行やスペースの有無は視覚的に分かりやすい
    - デザインにおける「近接」のように、近くにあるものは単一のグループとして認識され、離れているものは別のグループとして認識される
        - 近くに書く必要があるということにし、離れている必要があるということにすると、その認識とパーサの挙動は近づくと思う
    - 標準的なフォーマットで書けるという利点がある
        - Go風のセミコロン自動挿入と比較すると、ルールや実装はやや複雑になっている
        - 性能や実装難度は同じぐらい
