# Cells

スプレッドシート風アプリの実装

<https://7guis.github.io/7guis/tasks#cells>

## 詳細な説明

参考: <https://www.artima.com/pins1ed/the-scells-spreadsheet.html>

サンプルとしてのスプレッドシート風アプリには以下のような興味深さがある:

- スプレッドシートの挙動はよく知られている
- 数式のパースや評価など、GUIでない非自明な部分を含む
- テーブルのインクリメンタル更新の側面を持つ
- リアクティブ計算の側面を持つ
- 再利用可能なコンポーネントとしての側面を持つ

### UI実装

上記のサンプルはSwingのデータグリッドのようなものを利用している。
スクロールやセルの編集などの機能はすでにあるらしい

### 入力値と計算値

スプレッドシートのセルは単に入力された値を表示するだけでなく、計算した値を表示する機能を持っている。
入力値からなるテーブルと、内部表現からなるテーブルの2つを用意する。
セルは、フォーカスがあるときや編集中は入力値を表示し、ないときは計算値を表示することにする

### 数式

**数式** (Formula) は以下の種類からなる:

- 数値
- テキスト
- セルの参照
- セル範囲の参照
- 関数呼び出し

計算式の構文は関数記法だけ使う。
例えば和を `add(x, y)` と表記する

備考: 通常の数学で使われる記法を **中置記法** (infix notation) という。
`x + y` のように演算子を間に置く。
今回は使わない

以下の組み込み関数がある:

- `add(x, y)`: 加算 (`x + y`)
- `sub(x, y)`: 減算 (`x - y`)
- `mul(x, y)`: 乗算 (`x * y`)
- `div(x, y)`: 除算 (`x / y`)
- `sum(xs...)`: 総和 (`x1 + x2 + ... + xN`)
- `prod(xs...)`: 総積 (`x1 * x2 * ... * xN`)

sum, prodは可変個の引数を持つ

### 参照

セルの **座標** (coord) を書くことで、他のセルの値を参照する記法がある。
座標は列番号をアルファベット表記の後ろに行番号を書くことで表す。
列番号 (左から何列目か) は、左からA, B, C, ..., Zとする。
例えば左上のセルは `A0` と表す。その右は `B0`、下は `A1` である

なお列番号をアルファベット1文字で表せるように、列数は26列までとする。
エクセルでは27列目はAAと表記し、以降AB, AC, ..., ZZ, AAA, ...と増えていく

セルの **範囲** (range) は左上座標と右下座標をコロンでつないで、`A0:B1` のように書く。
右下座標は範囲に含む (いわゆる閉区間)

### 数式のパース

文字列として与えられた数式を適切な中間表現 (構文木) に変換することを **構文解析** (parsing) あるいは **パース** という

はじめに数式を **トークン** のリストに分割する。
トークンは構文的に分割されない文字列を表す。
例えば `add` のような識別子は1個のトークンである。
というのも、`add` は `a`, `d`, `d` の3文字に分かれているより、1つのものとして扱うほうが都合がよいのである

トークンは以下の種類がある:

- 数値 (e.g. `3.14`)
- 識別子 (e.g. `add`)
- 参照 (e.g. `A0`)
- 記号
    - コロンやカッコは1文字で1トークンになる

また、空白は捨てる。上記以外の文字が出現したら、エラーとする

次に数式を表現するデータ構造を定義する。
Rustでは以下のような構造にするとよい:

```rs
enum Formula {
    Number(f64),
    Text(String),
    Ref(Coord),
    Range(CoordRange),
    Call { name: String, args: Vec<Formula> },
}
```

その後、 **LL法** を使って、トークン列を読み進めながら数式を構築することでパースが完了する。

LL法は、トークンの種類ごとに分岐して期待されるトークンを読み進めていき、必要に応じて再帰的にパースを行うというパースアルゴリズム。
いってしまえばただの再帰である。
疑似コードでは以下のような手順になる:

```rust
/// トークン列をn個読み進める
fn shift(n: usize) { /* ... */ }

/// 数式をパースする
fn parse_formula() {
    match /* 次のトークン */ {
        // 次のトークンが数値なら: その数値からなる数式を構築する
        Number(value) => {
            shift(1);
            Formula::Number(value)
        }

        // 次のトークンが座標のとき、以下の2パターンがある:
        //      - 座標からなる数式
        //      - 「座標 ':' 座標」の順で出現する範囲の数式
        // 座標の後ろにコロンがあるかどうかで判別する
        Coord(coord) => {
            shift(1);
            match /* 次のトークン2つ */ {
                (Colon, Coord(coord2)) => {
                    shift(2);
                    Formula::Range(coord, coord2)
                }
                _ => Formula::Ref(coord),
            }
        },

        // 次のトークンが識別子のとき、関数呼び出しであることが分かる
        // この後に「'(' 引数リスト ')'」が出現すると期待できる
        Ident(name) => {
            // '(' を読む
            shift(1);

            let mut args = vec![];
            if /* 次のトークンが ')' でなければ */ {
                loop {
                    match /* 次のトークン */ {
                        // 次のトークンが式の先頭としてありえるものだったら、引数式を再帰的にパースする
                        Number(_) | Coord(_) | Ident(_) => {
                            args.push(parse_formula());

                            match /* 次のトークン */ {
                                // 引数式の後にカンマがあるなら、引数リストを継続する
                                Comma => { shift(1); continue; },
                                // 右カッコが出てきたら、引数リストは終了する
                                RightParen => break,
                                _ => /* エラー */,
                            }
                        }
                        _ => /* エラー */,
                    }
                }
            }

            // ')' を読む
            shift(1);
        }
    }
}
```

数式のパースを終えた時点ですべてのトークンを読み進めたことを確認すること。
そうでないと `1 2` のような不正な式がパースに成功してしまう

以上で数式を中間表現に変換できた。
次にそれを使って計算を行う

### 数式の評価

数式の値を計算することを **評価** (evaluation) という。
評価は、数式を再帰的に処理することで容易に実装できる

**エラーの表現**: 評価中にエラーが起こることはよくある。
範囲外のセルを参照している、未定義の関数を使っている、関数の引数の個数が誤っている、算術演算が未定義だったりオーバーフローする。
元の記事では結果をNaNにすることで対処しているが、Rustでは `Option` または `Result` を使えばよいだろう

余談: sum関数の引数は単一の値だけでなく範囲でもよい。
    元の記事では数式を値の列に評価する関数 (evalList) を用意しておくと便利だと提案している。
    この実装では使わなかった

### 変更の伝播

元の記事ではイベントベースのpub-subフレームワークを使っている。
具体的には以下のようにする:

- セルの入力値や計算値が変化したときに、セルがイベントを発行できるようにしておく
- セルに数式が設定される際に、その数式が参照している他のセルのイベントを購読して自身の計算値を再計算する処理を登録しておく
    - (数式の変更時に以前の数式が参照していたセルの購読を解除すること)

この方法ではセルが **循環参照** を起こしている場合、再計算処理が停止しないことがある。
Cellsのタスクとしては、その状態でもOKとみなされる。
回避方法として、「単に1ステップだけ再評価を進める」こともアリとしている

このサンプルでは **トポロジカルソート** を使うことで対処する。
セルが他のセルを参照している場合、後者のセルが前者の前になるように、セルに順番づけを行う。
順番通りに計算していけば再計算が適切に行われるという方法である

参照されているセルを先に、参照しているセルを後に計算しないと、セルの参照値を取得する際に古い値を読んでしまう。
トポロジカルソートを使うとそのような状況を回避できる

はじめ、入力値が変化したセルの集合がある。
数式の参照をみて、それらのセルが参照している他のセルを列挙する。
これを再帰的に繰り返すことで、再計算が必要なセルがすべて見つかる。
セルが列挙された順番とは逆の順番で再計算を進めていくことで、適切な順番で再計算できる

再帰処理の最中、セルが参照しているセルとしてそのセル自身が列挙された場合、循環参照が発生していることを意味する。
これを検出することにより、循環参照をエラーとして報告できる

詳しくは実装に書いてあるコメントも参照

### 追加作業の提案

以上でCellsの実装は完了となる

元の記事では、さらに作業を行いたいもののために以下のことを提案している:

- スプレッドシートをリサイズ可能にする
- 数式の種類を増やす。中置記法に対応する
- セルの循環参照に対処する (本サンプルは対応済み)
- エラー処理を改善する。数式のエラーの理由を表示する
- スプレッドシートの上部に数式の入力欄を配置する
