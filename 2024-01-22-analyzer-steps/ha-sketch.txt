# スケッチ

全体の流れを検討する

- step1
    もっとも単純なかたちの命令 (`dim a` と `mes a`) の構文解析を目指す
        構文解析は行単位、split命令でごまかす
    シンボル参照検索を実装して最低限のアナライザを完成させる
        変数の定義箇所・使用箇所の列挙
- step2
    deffuncを追加する (moduleはないのでstopの後に書く)
    シンボル参照の検索: deffuncによって定義された命令の定義箇所・使用箇所も含むように拡張される
- step3
    deffuncのパラメータを追加する
    シンボル参照の検索: パラメータの定義箇所・使用箇所を含む。行番号にもとづいて定義が「みえる」かどうかが変わる
- step4
    入力補完を実装する
- step5
    その他のアシストを入れられるだけ入れる (hover, rename, signature help)
    (これらのアシストは次のステップに残さない。作業量が増えるから)
- step6
    moduleを追加する



- step
    字句解析
        この時点で演算子や関数がないから字句解析のメリットが不明瞭
        (関数式のシグネチャヘルプを先に導入する?)
- step
    構文解析
- step
    include

- stepN

重要な点である解析木の構築とセマンティックモデルの生成、3種のアシスト、クエリシステムのインクリメンタル化を早めに済ませる
LSPサーバーやVSCode拡張機能のセットアップはそれ自体が大変なので後回しにする
mesboxで簡易のテキストエディタを作ってウィンドウ内で処理が完結すると、簡単だしデバッグしやすい
evalがあってもいい (代入文の右辺が定数式である場合にホバーで計算結果を表示する)



もっとも簡単なケースからスタートする
dim, mes だけでかなりの数の診断を実装できる
シグネチャヘルプ: 構文木のノードの形状が単純だからやりやすい
入力補完: スコープがないから変数名とキーワードを列挙するだけの虚無

----

メモ: hsp3-analyzer-mini が実装している機能のアウトライン (これらの実装を目指す):

- データ構造
    - ロケーション(location)
    - 字句列(tokens)
    - 解析木(AST)
    - 名前空間(namespace)、スコープ(scope)
- 操作
    - 字句解析(tokenize)
    - 構文解析(parse)
    - 名前解決(nameres)
    - hsphelpの解析
- アシスト
    - (入力)
        - ドキュメントデータベース (docs (text documents))
        - ファイルウォッチャー (file watcher; LSPの機能で実現)
        - ファイルスキャン (common、hsphelp)
    - コードアクション(code action)
        - rewrites: カンマの両側を交換、インクルードガードの生成
        - コードフォーマット(formatting)
    - シンボル参照の検索
        - 定義(definitions)、参照(references)
        - ホバー(hover)
        - ドキュメントハイライト、ドキュメントシンボル
        - 名前の変更(rename)
    - 解析
        - 診断(diagnosis)
        - 入力補完(completion)、シグネチャヘルプ(signature help)
        - リント(lint)
- インターフェイス
    - LSPサーバー (lsp_server)
    - ~~C API~~
- ユーティリティ
    - 文字コード変換 (encoding)
    - 参照カウント文字列 (rc_str)

----

メモ: hspの機能の簡略化

(はじめは機能を絞って実装を自己完結させる。段階的に対応する機能を増やし、アナライザの完成度を上げる。その過程で、機能の絞りかた (どう絞れば実装を楽にできるか) の検討が必要である)
(現状のhsp3-analyzer-miniもかなり対応する機能を絞っている。HSPの機能をすべて拾えるような設計にはなってない)

プリプロセッサ関連:

- `include` をファイル間の依存関係だけみる
    (moduleやdefineなど、後続に影響を与えるプリプロセッサ命令の後にincludeを書くと、includeされるスクリプトの解釈がinclude箇所によって変化する。代わりに、includeしたファイルからは、includeされたファイルのシンボルがみえているというだけにする)
- マクロシステムを無視する
    (defineによるマクロの定義・展開、ifdefなどによる分岐)
    - switchなどのよくあるマクロはそういう構文とみなして解析したほうが楽
- 構文解析とプリプロセッサの解析を分離する
    (構文解析を先に済ませて、それから `deffunc` などの処理をする)
    - これをすると `a*b` や `a(x)+2` などの文の解釈が曖昧になる
        (`a (*b)` vs. `a *= b`)
        (`a (x+2)` vs. `a(x) += 2`)
    - HSPのコンパイラはプリプロセッサを文字通り先に処理するので `a` が命令かどうか知った状態で構文解析を行うため曖昧な解析ができている。アナライザを同様の設計にしてもいい
- キーワードのundef
    (`#undef if` とか)

構文:

- if文の解析:
    - if命令の後に `{}` が出現できるので、`if`, `else` はキーワードとみなすほうが解析しやすい
        - `if :` と `if {}` は別の構文扱いでもいい、前者の入れ子は無視してもいい
        - `if : stmts { stmts }` というのを一般のかたちとみなす
- 中置式
    - 左再帰の除去をしなくてもシンボル参照検索などの処理結果に影響しないので、いったん右再帰とみなしていい
    - 演算子の結合力(優先度)を処理しなくても同様に影響が小さいため無視していい
        (上記2つを合わせると、`a + b * x == 0` が `(a + (b * (x == 0)))` になってしまう)

名前:

- (これもコンパイラはプリプロセッサを先に処理し、includeを展開しながら名前解決を行っているため、ファイルごとに処理をしようとすると違いが生じる)
- 名前空間、スコープ、環境などの扱いについてはhsp3-analyzer-mini/docsにノートを書いた

----

アナライザ特有の抽象

言語仕様やコンパイラでは使用されていない概念をアナライザのために導入している面がある

コンパイラとアナライザの違い: コンパイラとアナライザはどちらもスクリプトを解析するが、最終目標が異なる。コンパイラは最終的に実行ファイルを生成する。アナライザは問い合わせシステムを形成する。
ここで問い合わせシステムというのは、

- アナリシス(analysis; 解析結果)
- プロジェクト、ワークスペース
    - ここでは「プロジェクト」は「1つのスクリプトをコンパイルするために必要なファイルの集まりのこと」としている
    - スクリプトをコンパイルするとき、includeしているファイルを開く。そのファイルもまたincludeを含んでいることがある。include先のファイルを次々に展開したとき、最終的に使うことになったスクリプトファイルの集まりをプロジェクトということにする
        (推移的閉包)
    - ここでは「ワークスペース」は「すべてのプロジェクトの集まり」＋「HSPのシステムディレクトリ」としている。単にテキストエディタで開かれているディレクトリことだと思っていい。アナライザが処理を行うためにみる可能性があるすべてのファイルはワークスペースに含まれるみなす
        (要するに「全体」のこと)
    - 「プロジェクト」という概念の存在意義:
        プロジェクトごとにデータを分けて持ちたいから
        ファイルに変更があったとき、そのファイルを含まないプロジェクトにはまったく影響がない。影響がないプロジェクトに関連してもっているデータは更新しなくていい。データをプロジェクトと対応させるかたちで保持しておけば何を更新しなくていいか分かりやすくて扱いやすい
        (影響範囲の局所化による更新性能の改善)
